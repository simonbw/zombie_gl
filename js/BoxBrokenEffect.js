// Generated by CoffeeScript 1.7.1
(function() {
  var DRAG, EXPLOSION_FORCE, FADE, GRAVITY, LIFESPAN, PARTICLE_COUNT,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  PARTICLE_COUNT = 2 << 10;

  GRAVITY = 9.8 / 60.;

  DRAG = 0.99;

  FADE = 0.01;

  LIFESPAN = 150;

  EXPLOSION_FORCE = 3.0;

  window.BoxBrokenEffect = (function() {
    function BoxBrokenEffect(x, y, angle) {
      var colors, i, positions, texture, velocities;
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.dispose = __bind(this.dispose, this);
      this.update = __bind(this.update, this);
      this.init = __bind(this.init, this);
      this.lifespan = LIFESPAN;
      this.geom = new THREE.BufferGeometry();
      this.geom.dynamic = true;
      this.geom.attributes = {
        position: {
          itemSize: 3,
          array: new Float32Array(PARTICLE_COUNT * 3),
          numItems: PARTICLE_COUNT * 3
        },
        velocity: {
          itemSize: 3,
          array: new Float32Array(PARTICLE_COUNT * 3),
          numItems: PARTICLE_COUNT * 3
        },
        color: {
          itemSize: 3,
          array: new Float32Array(PARTICLE_COUNT * 3),
          numItems: PARTICLE_COUNT * 3
        }
      };
      positions = this.geom.attributes.position.array;
      velocities = this.geom.attributes.velocity.array;
      colors = this.geom.attributes.color.array;
      i = 0;
      while (i < PARTICLE_COUNT * 3) {
        positions[i] = (Math.random() - 0.5) * Box.SIZE;
        positions[i + 1] = (Math.random() - 0.5) * Box.SIZE;
        positions[i + 2] = (Math.random() - 0.5) * Box.SIZE;
        velocities[i] = Random.normal(EXPLOSION_FORCE);
        velocities[i + 1] = Random.normal(EXPLOSION_FORCE);
        velocities[i + 2] = Random.normal(EXPLOSION_FORCE);
        colors[i] = 0.35 + Math.random() * 0.4;
        colors[i + 1] = 0.3 + Math.random() * 0.3;
        colors[i + 2] = 0.2 + Math.random() * 0.2;
        i += 3;
      }
      this.geom.computeBoundingSphere();
      colors = this.geom.attributes.color.needsUpdate = true;
      texture = THREE.ImageUtils.loadTexture("resources/images/wood_hit.png");
      this.material = new THREE.ParticleSystemMaterial({
        vertexColors: THREE.VertexColors,
        size: 0.02,
        transparent: true
      });
      this.material.depthWrite = false;
      this.particles = new THREE.ParticleSystem(this.geom, this.material);
      this.particles.sortParticles = true;
      this.particles.position.set(this.x, this.y, Box.SIZE / 2);
      this.particles.rotation.z = this.angle;
    }

    BoxBrokenEffect.prototype.init = function(game) {
      return game.scene.add(this.particles);
    };

    BoxBrokenEffect.prototype.update = function(game) {
      var i, positions, velocities;
      positions = this.geom.attributes.position.array;
      velocities = this.geom.attributes.velocity.array;
      i = 0;
      while (i < PARTICLE_COUNT * 3) {
        positions[i] += velocities[i] / 60;
        positions[i + 1] += velocities[i + 1] / 60;
        positions[i + 2] += velocities[i + 2] / 60;
        velocities[i] *= DRAG;
        velocities[i + 1] *= DRAG;
        velocities[i + 2] *= DRAG;
        velocities[i + 2] -= GRAVITY;
        if (positions[i + 2] <= -Box.SIZE / 2) {
          positions[i + 2] = -Box.SIZE / 2 + 0.0001;
          velocities[i + 2] *= -0.5;
          velocities[i] *= 0.5;
          velocities[i + 1] *= 0.5;
          if (Math.abs(velocities[i]) < 0.001) {
            velocities[i] = 0;
          }
          if (Math.abs(velocities[i + 1]) < 0.001) {
            velocities[i + 1] = 0;
          }
          if (Math.abs(velocities[i + 2]) < 0.001) {
            velocities[i + 2] = 0;
          }
        }
        i += 3;
      }
      this.geom.attributes.position.needsUpdate = true;
      this.geom.attributes.velocity.needsUpdate = true;
      this.geom.computeBoundingSphere();
      this.material.opacity = Math.min(2.0 * this.lifespan / LIFESPAN, 1.0);
      this.lifespan--;
      if (this.lifespan <= 0) {
        return game.removeEntity(this);
      }
    };

    BoxBrokenEffect.prototype.dispose = function(game) {
      if (this.disposed) {
        console.log("removing HitEffect twice");
      }
      this.disposed = true;
      return game.scene.remove(this.particles);
    };

    return BoxBrokenEffect;

  })();

}).call(this);

//# sourceMappingURL=BoxBrokenEffect.map
