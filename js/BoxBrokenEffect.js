// Generated by CoffeeScript 1.8.0
(function() {
  var AIR_ANGULAR_DRAG, AIR_DRAG, BACK, BOTTOM, EXPLOSION_FORCE, FRONT, GRAVITY, GROUND_ANGULAR_DRAG, GROUND_DRAG, LEFT, LIFESPAN, OFFSET, RIGHT, ROTATION_ACCEL, SIZE, TOP,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GRAVITY = 9.8 / 60.;

  AIR_DRAG = 0.999;

  AIR_ANGULAR_DRAG = 0.995;

  GROUND_DRAG = 0.95;

  GROUND_ANGULAR_DRAG = 0.94;

  LIFESPAN = 150;

  EXPLOSION_FORCE = 0.8;

  ROTATION_ACCEL = 0.005;

  OFFSET = 7.765;

  TOP = 0;

  BOTTOM = 1;

  LEFT = 2;

  RIGHT = 3;

  FRONT = 4;

  BACK = 5;

  SIZE = Box.SIZE;

  window.BoxBrokenEffect = (function() {
    BoxBrokenEffect.material = new THREE.MeshPhongMaterial({
      side: THREE.DoubleSide,
      map: Box.texture,
      bumpMap: Box.bumpMap,
      bumpScale: 0.02
    });

    function BoxBrokenEffect(x, y, angle) {
      var geometry, i, mesh, _i, _len, _ref;
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.dispose = __bind(this.dispose, this);
      this.update = __bind(this.update, this);
      this.init = __bind(this.init, this);
      this.lifespan = LIFESPAN;
      this.meshes = [];
      this.velocities = [];
      this.offsets = [];
      this.spins = [];
      this.meshContainer = new THREE.Object3D();
      this.meshContainer.position.set(this.x, this.y, SIZE / 2 + 0.001);
      this.meshContainer.rotation.z = this.angle;
      _ref = [TOP, BOTTOM, LEFT, RIGHT, FRONT, BACK];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        geometry = new THREE.PlaneGeometry(SIZE, SIZE);
        mesh = new THREE.Mesh(geometry, BoxBrokenEffect.material);
        this.meshes.push(mesh);
        this.meshContainer.add(mesh);
        this.velocities.push(new THREE.Vector3());
        this.spins.push(new THREE.Vector3());
        this.offsets.push(new THREE.Vector3());
      }
      this.meshes[TOP].position.z = SIZE / 2;
      this.velocities[TOP].x = Random.normal(1.0);
      this.velocities[TOP].y = Random.normal(1.0);
      this.velocities[TOP].z = (Math.random() + 0.1) * EXPLOSION_FORCE;
      this.spins[TOP].z = Random.normal(0.05);
      this.meshes[BOTTOM].position.z = -SIZE / 2;
      this.spins[BOTTOM].z = Random.normal(0.03);
      this.meshes[RIGHT].position.x = SIZE / 2;
      this.meshes[RIGHT].rotation.y = -Math.PI / 2;
      this.spins[RIGHT].y = 0.02;
      this.velocities[RIGHT].x = EXPLOSION_FORCE * (Math.random() + 0.1);
      this.spins[RIGHT].z = Random.normal(0.03);
      this.meshes[LEFT].position.x = -SIZE / 2;
      this.meshes[LEFT].rotation.y = Math.PI / 2;
      this.spins[LEFT].y = -0.02;
      this.velocities[LEFT].x = -EXPLOSION_FORCE * (Math.random() + 0.1);
      this.spins[LEFT].z = Random.normal(0.03);
      this.meshes[FRONT].position.y = SIZE / 2;
      this.meshes[FRONT].rotation.x = Math.PI / 2;
      this.spins[FRONT].x = -0.02;
      this.velocities[FRONT].y = EXPLOSION_FORCE * (Math.random() + 0.1);
      this.spins[FRONT].z = Random.normal(0.03);
      this.meshes[BACK].position.y = -SIZE / 2;
      this.meshes[BACK].rotation.x = -Math.PI / 2;
      this.spins[BACK].x = 0.02;
      this.velocities[BACK].y = -EXPLOSION_FORCE * (Math.random() + 0.1);
      this.spins[BACK].z = Random.normal(0.03);
    }

    BoxBrokenEffect.prototype.init = function(game) {
      return game.scene.add(this.meshContainer);
    };

    BoxBrokenEffect.prototype.update = function(game) {
      var fallen, grounded, i, mesh, _i, _ref, _results;
      this.velocities[BOTTOM].multiplyScalar(GROUND_DRAG);
      this.spins[BOTTOM].z *= GROUND_ANGULAR_DRAG;
      if (this.meshes[TOP].position.z > -SIZE / 2) {
        this.velocities[TOP].z -= GRAVITY;
        this.velocities[TOP].x *= AIR_DRAG;
        this.velocities[TOP].y *= AIR_DRAG;
        this.spins[TOP].z *= AIR_ANGULAR_DRAG;
      } else {
        this.velocities[TOP].z = 0;
        this.velocities[TOP].x *= GROUND_DRAG;
        this.velocities[TOP].y *= GROUND_DRAG;
        this.meshes[TOP].position.z = -SIZE / 2;
        this.spins[TOP].z *= GROUND_ANGULAR_DRAG;
      }
      if (this.meshes[LEFT].rotation.y > 0) {
        this.spins[LEFT].y += Math.sign(this.spins[LEFT].y) * ROTATION_ACCEL;
      } else {
        this.spins[LEFT].y = 0;
        this.meshes[LEFT].rotation.y = 0;
      }
      grounded = 1 - Math.abs(this.meshes[LEFT].rotation.y / (Math.PI / 2));
      this.spins[LEFT].multiplyScalar(AIR_ANGULAR_DRAG * (1 - grounded) + GROUND_ANGULAR_DRAG * grounded);
      this.velocities[LEFT].multiplyScalar(AIR_DRAG * (1 - grounded) + GROUND_DRAG * grounded);
      fallen = Math.abs(Math.sin(this.meshes[LEFT].rotation.y) * SIZE / 2);
      this.meshes[LEFT].position.z = fallen * SIZE / 2 - SIZE / 2;
      this.offsets[LEFT].x = -fallen * SIZE / 2 / OFFSET;
      if (this.meshes[RIGHT].rotation.y < 0) {
        this.spins[RIGHT].y += Math.sign(this.spins[RIGHT].y) * ROTATION_ACCEL;
      } else {
        this.spins[RIGHT].y = 0;
        this.meshes[RIGHT].rotation.y = 0;
      }
      grounded = 1 - Math.abs(this.meshes[RIGHT].rotation.y / (Math.PI / 2));
      this.spins[RIGHT].multiplyScalar(AIR_ANGULAR_DRAG * (1 - grounded) + GROUND_ANGULAR_DRAG * grounded);
      this.velocities[RIGHT].multiplyScalar(AIR_DRAG * (1 - grounded) + GROUND_DRAG * grounded);
      fallen = Math.abs(Math.sin(this.meshes[RIGHT].rotation.y) * SIZE / 2);
      this.meshes[RIGHT].position.z = fallen * SIZE / 2 - SIZE / 2;
      this.offsets[RIGHT].x = fallen * SIZE / 2 / OFFSET;
      if (this.meshes[FRONT].rotation.x > 0) {
        this.spins[FRONT].x += Math.sign(this.spins[FRONT].x) * ROTATION_ACCEL;
      } else {
        this.spins[FRONT].x = 0;
        this.meshes[FRONT].rotation.x = 0;
      }
      grounded = 1 - Math.abs(this.meshes[FRONT].rotation.x / (Math.PI / 2));
      this.spins[FRONT].multiplyScalar(AIR_ANGULAR_DRAG * (1 - grounded) + GROUND_ANGULAR_DRAG * grounded);
      this.velocities[FRONT].multiplyScalar(AIR_DRAG * (1 - grounded) + GROUND_DRAG * grounded);
      fallen = Math.abs(Math.sin(this.meshes[FRONT].rotation.x) * SIZE / 2);
      this.meshes[FRONT].position.z = fallen * SIZE / 2 - SIZE / 2;
      this.offsets[FRONT].y = fallen * SIZE / 2 / OFFSET;
      if (this.meshes[BACK].rotation.x < 0) {
        this.spins[BACK].x += Math.sign(this.spins[BACK].x) * ROTATION_ACCEL;
      } else {
        this.spins[BACK].x = 0;
        this.meshes[BACK].rotation.x = 0;
      }
      grounded = 1 - Math.abs(this.meshes[BACK].rotation.x / (Math.PI / 2));
      this.spins[BACK].multiplyScalar(AIR_ANGULAR_DRAG * (1 - grounded) + GROUND_ANGULAR_DRAG * grounded);
      this.velocities[BACK].multiplyScalar(AIR_DRAG * (1 - grounded) + GROUND_DRAG * grounded);
      fallen = Math.abs(Math.sin(this.meshes[BACK].rotation.x) * SIZE / 2);
      this.meshes[BACK].position.z = fallen * SIZE / 2 - SIZE / 2;
      this.offsets[BACK].y = -fallen * SIZE / 2 / OFFSET;
      _results = [];
      for (i = _i = 0, _ref = this.meshes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        mesh = this.meshes[i];
        mesh.position.x += this.velocities[i].x / 60;
        mesh.position.y += this.velocities[i].y / 60;
        mesh.position.z += this.velocities[i].z / 60;
        mesh.position.x += this.offsets[i].x;
        mesh.position.y += this.offsets[i].y;
        mesh.position.z += this.offsets[i].z;
        mesh.rotation.x += this.spins[i].x;
        mesh.rotation.y += this.spins[i].y;
        _results.push(mesh.rotation.z += this.spins[i].z);
      }
      return _results;
    };

    BoxBrokenEffect.prototype.dispose = function(game) {
      if (this.disposed) {
        console.log("removing HitEffect twice");
      }
      this.disposed = true;
      return game.scene.remove(this.meshContainer);
    };

    return BoxBrokenEffect;

  })();

}).call(this);

//# sourceMappingURL=BoxBrokenEffect.js.map
