// Generated by CoffeeScript 1.7.1
(function() {
  var DRAG, EXPLOSION_FORCE, FADE, GRAVITY, LIFESPAN, PARTICLE_COUNT,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  PARTICLE_COUNT = 2 << 10;

  GRAVITY = 9.8 / 60.;

  DRAG = 0.99;

  FADE = 0.01;

  LIFESPAN = 150;

  EXPLOSION_FORCE = 3.0;

  window.BoxBrokenEffect = (function() {
    BoxBrokenEffect.material = new THREE.MeshPhongMaterial({
      side: THREE.DoubleSide,
      map: Box.texture,
      bumpMap: Box.bumpMap,
      bumpScale: 0.02
    });

    function BoxBrokenEffect(x, y, angle) {
      var geometry, i, mesh, size, _i;
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.dispose = __bind(this.dispose, this);
      this.update = __bind(this.update, this);
      this.init = __bind(this.init, this);
      this.lifespan = LIFESPAN;
      this.meshes = [];
      this.velocities = [];
      this.spins = [];
      this.meshContainer = new THREE.Object3D();
      this.meshContainer.position.set(this.x, this.y, Box.SIZE / 2);
      this.meshContainer.rotation.z = this.angle;
      size = Box.SIZE;
      for (i = _i = 0; _i < 6; i = ++_i) {
        geometry = new THREE.PlaneGeometry(size, size);
        mesh = new THREE.Mesh(geometry, BoxBrokenEffect.material);
        this.meshes.push(mesh);
        this.meshContainer.add(mesh);
        this.velocities.push(new THREE.Vector3());
        this.spins.push(new THREE.Vector3());
      }
      this.meshes[0].position.z = size / 2;
      this.meshes[5].position.z = -size / 2;
      this.meshes[1].position.x = size / 2;
      this.meshes[1].rotation.y = Math.PI / 2;
      this.meshes[2].position.x = -size / 2;
      this.meshes[2].rotation.y = -Math.PI / 2;
      this.meshes[3].position.y = size / 2;
      this.meshes[3].rotation.x = Math.PI / 2;
      this.meshes[4].position.y = -size / 2;
      this.meshes[4].rotation.x = -Math.PI / 2;
      this.velocities[0].x = Random.normal(1.0);
      this.velocities[0].y = Random.normal(1.0);
      this.velocities[0].z = Math.random() * 2 + 3.0;
      this.spins[0].z = Random.normal(0.05);
    }

    BoxBrokenEffect.prototype.init = function(game) {
      return game.scene.add(this.meshContainer);
    };

    BoxBrokenEffect.prototype.update = function(game) {
      var i, mesh, _i, _ref;
      if (this.meshes[0].position.z > 0.0001) {
        this.velocities[0].z -= GRAVITY;
        this.velocities[0].x *= 0.9998;
        this.velocities[0].y *= 0.9998;
        this.spins[0].z *= 0.99;
      } else {
        this.velocities[0].z = 0;
        this.velocities[0].x *= 0.94;
        this.velocities[0].y *= 0.94;
        this.meshes[0].position.z = 0.00005;
        this.spins[0].z *= 0.94;
      }
      for (i = _i = 0, _ref = this.meshes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        mesh = this.meshes[i];
        mesh.position.x += this.velocities[i].x / 60;
        mesh.position.y += this.velocities[i].y / 60;
        mesh.position.z += this.velocities[i].z / 60;
        mesh.rotation.x += this.spins[i].x;
        mesh.rotation.y += this.spins[i].y;
        mesh.rotation.z += this.spins[i].z;
      }
      this.lifespan--;
      if (this.lifespan <= 0) {
        return game.removeEntity(this);
      }
    };

    BoxBrokenEffect.prototype.dispose = function(game) {
      if (this.disposed) {
        console.log("removing HitEffect twice");
      }
      this.disposed = true;
      return game.scene.remove(this.meshContainer);
    };

    return BoxBrokenEffect;

  })();

}).call(this);

//# sourceMappingURL=BoxBrokenEffect.map
